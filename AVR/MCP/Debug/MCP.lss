
MCP.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  00000b18  00000bac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000b18  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000012f  00800102  00800102  00000bae  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000bae  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000be0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000110  00000000  00000000  00000c20  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000013b9  00000000  00000000  00000d30  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009b0  00000000  00000000  000020e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000ade  00000000  00000000  00002a99  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000398  00000000  00000000  00003578  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000064d  00000000  00000000  00003910  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000c92  00000000  00000000  00003f5d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000f0  00000000  00000000  00004bef  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 44 00 	jmp	0x88	; 0x88 <__ctors_end>
   4:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
   8:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
   c:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  10:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  14:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  18:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  1c:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  20:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  24:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  28:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  2c:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  30:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  34:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  38:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  3c:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  40:	0c 94 88 00 	jmp	0x110	; 0x110 <__vector_16>
  44:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  48:	0c 94 cb 02 	jmp	0x596	; 0x596 <__vector_18>
  4c:	0c 94 42 03 	jmp	0x684	; 0x684 <__vector_19>
  50:	0c 94 84 03 	jmp	0x708	; 0x708 <__vector_20>
  54:	0c 94 44 01 	jmp	0x288	; 0x288 <__vector_21>
  58:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  5c:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  60:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  64:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__bad_interrupt>
  68:	ea 00       	.word	0x00ea	; ????
  6a:	f3 00       	.word	0x00f3	; ????
  6c:	ff 00       	.word	0x00ff	; ????
  6e:	08 01       	movw	r0, r16
  70:	11 01       	movw	r2, r2
  72:	1e 01       	movw	r2, r28
  74:	3d 01       	movw	r6, r26
  76:	3d 01       	movw	r6, r26
  78:	3d 01       	movw	r6, r26
  7a:	3d 01       	movw	r6, r26
  7c:	3d 01       	movw	r6, r26
  7e:	3d 01       	movw	r6, r26
  80:	3d 01       	movw	r6, r26
  82:	3d 01       	movw	r6, r26
  84:	27 01       	movw	r4, r14
  86:	34 01       	movw	r6, r8

00000088 <__ctors_end>:
  88:	11 24       	eor	r1, r1
  8a:	1f be       	out	0x3f, r1	; 63
  8c:	cf ef       	ldi	r28, 0xFF	; 255
  8e:	d8 e0       	ldi	r29, 0x08	; 8
  90:	de bf       	out	0x3e, r29	; 62
  92:	cd bf       	out	0x3d, r28	; 61

00000094 <__do_copy_data>:
  94:	11 e0       	ldi	r17, 0x01	; 1
  96:	a0 e0       	ldi	r26, 0x00	; 0
  98:	b1 e0       	ldi	r27, 0x01	; 1
  9a:	e8 e1       	ldi	r30, 0x18	; 24
  9c:	fb e0       	ldi	r31, 0x0B	; 11
  9e:	02 c0       	rjmp	.+4      	; 0xa4 <__do_copy_data+0x10>
  a0:	05 90       	lpm	r0, Z+
  a2:	0d 92       	st	X+, r0
  a4:	a2 30       	cpi	r26, 0x02	; 2
  a6:	b1 07       	cpc	r27, r17
  a8:	d9 f7       	brne	.-10     	; 0xa0 <__do_copy_data+0xc>

000000aa <__do_clear_bss>:
  aa:	22 e0       	ldi	r18, 0x02	; 2
  ac:	a2 e0       	ldi	r26, 0x02	; 2
  ae:	b1 e0       	ldi	r27, 0x01	; 1
  b0:	01 c0       	rjmp	.+2      	; 0xb4 <.do_clear_bss_start>

000000b2 <.do_clear_bss_loop>:
  b2:	1d 92       	st	X+, r1

000000b4 <.do_clear_bss_start>:
  b4:	a1 33       	cpi	r26, 0x31	; 49
  b6:	b2 07       	cpc	r27, r18
  b8:	e1 f7       	brne	.-8      	; 0xb2 <.do_clear_bss_loop>
  ba:	0e 94 be 01 	call	0x37c	; 0x37c <main>
  be:	0c 94 8a 05 	jmp	0xb14	; 0xb14 <_exit>

000000c2 <__bad_interrupt>:
  c2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000c6 <timer0100us_start>:
volatile uint16_t holdingRegisters[4];

volatile uint16_t adc_results[4];

void timer0100us_start(void) {
	TCCR0B|=(1<<CS01); //prescaler 8
  c6:	85 b5       	in	r24, 0x25	; 37
  c8:	82 60       	ori	r24, 0x02	; 2
  ca:	85 bd       	out	0x25, r24	; 37
	TIMSK0|=(1<<TOIE0);
  cc:	ee e6       	ldi	r30, 0x6E	; 110
  ce:	f0 e0       	ldi	r31, 0x00	; 0
  d0:	80 81       	ld	r24, Z
  d2:	81 60       	ori	r24, 0x01	; 1
  d4:	80 83       	st	Z, r24
  d6:	08 95       	ret

000000d8 <SetOuts>:
}

/*
*   Modify the following 3 functions to implement your own pin configurations...
*/
void SetOuts(volatile uint8_t in) {
  d8:	cf 93       	push	r28
  da:	df 93       	push	r29
  dc:	1f 92       	push	r1
  de:	cd b7       	in	r28, 0x3d	; 61
  e0:	de b7       	in	r29, 0x3e	; 62
  e2:	89 83       	std	Y+1, r24	; 0x01
					CLEAR(B,5);
				}
				*/


				PORTB =(PORTB & 0b11000011) | (in << 2);
  e4:	95 b1       	in	r25, 0x05	; 5
  e6:	89 81       	ldd	r24, Y+1	; 0x01
  e8:	93 7c       	andi	r25, 0xC3	; 195
  ea:	88 0f       	add	r24, r24
  ec:	88 0f       	add	r24, r24
  ee:	89 2b       	or	r24, r25
  f0:	85 b9       	out	0x05, r24	; 5

}
  f2:	0f 90       	pop	r0
  f4:	df 91       	pop	r29
  f6:	cf 91       	pop	r28
  f8:	08 95       	ret

000000fa <ReadIns>:
	//{
	//ins = (0b00000000);
	//}
	//

	ins = (PIND >>2 ) ;
  fa:	89 b1       	in	r24, 0x09	; 9

	ins = (~ins & 0b00111111);
  fc:	86 95       	lsr	r24
  fe:	86 95       	lsr	r24
 100:	80 95       	com	r24

	return ins;
}
 102:	8f 73       	andi	r24, 0x3F	; 63
 104:	08 95       	ret

00000106 <io_conf>:
	//PORTC=0x00;
	//PORTD|=(1<<0);
	//DDRD |= (1<<2)|(1<<5)|(1<<6)|(1<<7);
	//DDRB |= (1<<0)|(1<<1)|(1<<2)|(1<<3);

	OUTPUT(B,5);
 106:	25 9a       	sbi	0x04, 5	; 4
	OUTPUT(B,4);
 108:	24 9a       	sbi	0x04, 4	; 4
	OUTPUT(B,3);
 10a:	23 9a       	sbi	0x04, 3	; 4
	OUTPUT(B,2);
 10c:	22 9a       	sbi	0x04, 2	; 4
 10e:	08 95       	ret

00000110 <__vector_16>:


}

ISR(TIMER0_OVF_vect) { //this ISR is called 9765.625 times per second
 110:	1f 92       	push	r1
 112:	0f 92       	push	r0
 114:	0f b6       	in	r0, 0x3f	; 63
 116:	0f 92       	push	r0
 118:	11 24       	eor	r1, r1
 11a:	2f 93       	push	r18
 11c:	3f 93       	push	r19
 11e:	4f 93       	push	r20
 120:	5f 93       	push	r21
 122:	6f 93       	push	r22
 124:	7f 93       	push	r23
 126:	8f 93       	push	r24
 128:	9f 93       	push	r25
 12a:	af 93       	push	r26
 12c:	bf 93       	push	r27
 12e:	ef 93       	push	r30
 130:	ff 93       	push	r31
	modbusTickTimer();
 132:	0e 94 85 02 	call	0x50a	; 0x50a <modbusTickTimer>

	

}
 136:	ff 91       	pop	r31
 138:	ef 91       	pop	r30
 13a:	bf 91       	pop	r27
 13c:	af 91       	pop	r26
 13e:	9f 91       	pop	r25
 140:	8f 91       	pop	r24
 142:	7f 91       	pop	r23
 144:	6f 91       	pop	r22
 146:	5f 91       	pop	r21
 148:	4f 91       	pop	r20
 14a:	3f 91       	pop	r19
 14c:	2f 91       	pop	r18
 14e:	0f 90       	pop	r0
 150:	0f be       	out	0x3f, r0	; 63
 152:	0f 90       	pop	r0
 154:	1f 90       	pop	r1
 156:	18 95       	reti

00000158 <modbusGet>:

void modbusGet(void) {
 158:	cf 93       	push	r28
 15a:	df 93       	push	r29
 15c:	1f 92       	push	r1
 15e:	cd b7       	in	r28, 0x3d	; 61
 160:	de b7       	in	r29, 0x3e	; 62


		static uint16_t i;
		static uint16_t j;

		if (j++ >10000)
 162:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <j.1796>
 166:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <j.1796+0x1>
 16a:	9c 01       	movw	r18, r24
 16c:	2f 5f       	subi	r18, 0xFF	; 255
 16e:	3f 4f       	sbci	r19, 0xFF	; 255
 170:	30 93 09 01 	sts	0x0109, r19	; 0x800109 <j.1796+0x1>
 174:	20 93 08 01 	sts	0x0108, r18	; 0x800108 <j.1796>
 178:	81 31       	cpi	r24, 0x11	; 17
 17a:	97 42       	sbci	r25, 0x27	; 39
 17c:	c8 f0       	brcs	.+50     	; 0x1b0 <modbusGet+0x58>
		{
		
			if (i++ >10)
 17e:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <i.1795>
 182:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <i.1795+0x1>
 186:	9c 01       	movw	r18, r24
 188:	2f 5f       	subi	r18, 0xFF	; 255
 18a:	3f 4f       	sbci	r19, 0xFF	; 255
 18c:	30 93 07 01 	sts	0x0107, r19	; 0x800107 <i.1795+0x1>
 190:	20 93 06 01 	sts	0x0106, r18	; 0x800106 <i.1795>
 194:	0b 97       	sbiw	r24, 0x0b	; 11
 196:	40 f0       	brcs	.+16     	; 0x1a8 <modbusGet+0x50>
			{
				TOGGLE(B,0);
 198:	95 b1       	in	r25, 0x05	; 5
 19a:	81 e0       	ldi	r24, 0x01	; 1
 19c:	89 27       	eor	r24, r25
 19e:	85 b9       	out	0x05, r24	; 5
				i = 0;
 1a0:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <i.1795+0x1>
 1a4:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <i.1795>
				}

				j=0;
 1a8:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <j.1796+0x1>
 1ac:	10 92 08 01 	sts	0x0108, r1	; 0x800108 <j.1796>
	}

	if (modbusGetBusState() & (1<<ReceiveCompleted))
 1b0:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <modbusGetBusState>
 1b4:	83 ff       	sbrs	r24, 3
 1b6:	64 c0       	rjmp	.+200    	; 0x280 <modbusGet+0x128>
	{
		switch(rxbuffer[1]) {
 1b8:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <rxbuffer+0x1>
 1bc:	8e 2f       	mov	r24, r30
 1be:	90 e0       	ldi	r25, 0x00	; 0
 1c0:	fc 01       	movw	r30, r24
 1c2:	31 97       	sbiw	r30, 0x01	; 1
 1c4:	e0 31       	cpi	r30, 0x10	; 16
 1c6:	f1 05       	cpc	r31, r1
 1c8:	08 f0       	brcs	.+2      	; 0x1cc <modbusGet+0x74>
 1ca:	57 c0       	rjmp	.+174    	; 0x27a <modbusGet+0x122>
 1cc:	ec 5c       	subi	r30, 0xCC	; 204
 1ce:	ff 4f       	sbci	r31, 0xFF	; 255
 1d0:	0c 94 84 05 	jmp	0xb08	; 0xb08 <__tablejump2__>
			case fcReadCoilStatus: {
				modbusExchangeBits(&outstate,0,8);
 1d4:	48 e0       	ldi	r20, 0x08	; 8
 1d6:	50 e0       	ldi	r21, 0x00	; 0
 1d8:	60 e0       	ldi	r22, 0x00	; 0
 1da:	70 e0       	ldi	r23, 0x00	; 0
 1dc:	8a e0       	ldi	r24, 0x0A	; 10
 1de:	91 e0       	ldi	r25, 0x01	; 1
 1e0:	0e 94 b9 04 	call	0x972	; 0x972 <modbusExchangeBits>
			}
			break;
 1e4:	4d c0       	rjmp	.+154    	; 0x280 <modbusGet+0x128>
			
			case fcReadInputStatus: {
				volatile uint8_t inps = ReadIns(); //change by test
 1e6:	0e 94 7d 00 	call	0xfa	; 0xfa <ReadIns>
 1ea:	89 83       	std	Y+1, r24	; 0x01
				modbusExchangeBits(&inps,0,8);
 1ec:	48 e0       	ldi	r20, 0x08	; 8
 1ee:	50 e0       	ldi	r21, 0x00	; 0
 1f0:	60 e0       	ldi	r22, 0x00	; 0
 1f2:	70 e0       	ldi	r23, 0x00	; 0
 1f4:	ce 01       	movw	r24, r28
 1f6:	01 96       	adiw	r24, 0x01	; 1
 1f8:	0e 94 b9 04 	call	0x972	; 0x972 <modbusExchangeBits>
			}
			break;
 1fc:	41 c0       	rjmp	.+130    	; 0x280 <modbusGet+0x128>
			
			case fcReadHoldingRegisters: {
				modbusExchangeRegisters(holdingRegisters,0,4);
 1fe:	44 e0       	ldi	r20, 0x04	; 4
 200:	50 e0       	ldi	r21, 0x00	; 0
 202:	60 e0       	ldi	r22, 0x00	; 0
 204:	70 e0       	ldi	r23, 0x00	; 0
 206:	81 e1       	ldi	r24, 0x11	; 17
 208:	91 e0       	ldi	r25, 0x01	; 1
 20a:	0e 94 19 04 	call	0x832	; 0x832 <modbusExchangeRegisters>
			}
			break;
 20e:	38 c0       	rjmp	.+112    	; 0x280 <modbusGet+0x128>
			
			case fcReadInputRegisters: {
				modbusExchangeRegisters(inputRegisters,0,8);
 210:	48 e0       	ldi	r20, 0x08	; 8
 212:	50 e0       	ldi	r21, 0x00	; 0
 214:	60 e0       	ldi	r22, 0x00	; 0
 216:	70 e0       	ldi	r23, 0x00	; 0
 218:	81 e2       	ldi	r24, 0x21	; 33
 21a:	91 e0       	ldi	r25, 0x01	; 1
 21c:	0e 94 19 04 	call	0x832	; 0x832 <modbusExchangeRegisters>
			}
			break;
 220:	2f c0       	rjmp	.+94     	; 0x280 <modbusGet+0x128>
			
			case fcForceSingleCoil: {
				modbusExchangeBits(&outstate,0,8);
 222:	48 e0       	ldi	r20, 0x08	; 8
 224:	50 e0       	ldi	r21, 0x00	; 0
 226:	60 e0       	ldi	r22, 0x00	; 0
 228:	70 e0       	ldi	r23, 0x00	; 0
 22a:	8a e0       	ldi	r24, 0x0A	; 10
 22c:	91 e0       	ldi	r25, 0x01	; 1
 22e:	0e 94 b9 04 	call	0x972	; 0x972 <modbusExchangeBits>
				SetOuts(outstate);
 232:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <outstate>
 236:	0e 94 6c 00 	call	0xd8	; 0xd8 <SetOuts>
			}
			break;
 23a:	22 c0       	rjmp	.+68     	; 0x280 <modbusGet+0x128>
			
			case fcPresetSingleRegister: {
				modbusExchangeRegisters(holdingRegisters,0,4);
 23c:	44 e0       	ldi	r20, 0x04	; 4
 23e:	50 e0       	ldi	r21, 0x00	; 0
 240:	60 e0       	ldi	r22, 0x00	; 0
 242:	70 e0       	ldi	r23, 0x00	; 0
 244:	81 e1       	ldi	r24, 0x11	; 17
 246:	91 e0       	ldi	r25, 0x01	; 1
 248:	0e 94 19 04 	call	0x832	; 0x832 <modbusExchangeRegisters>
			}
			break;
 24c:	19 c0       	rjmp	.+50     	; 0x280 <modbusGet+0x128>
			
			case fcForceMultipleCoils: {
				modbusExchangeBits(&outstate,0,8);
 24e:	48 e0       	ldi	r20, 0x08	; 8
 250:	50 e0       	ldi	r21, 0x00	; 0
 252:	60 e0       	ldi	r22, 0x00	; 0
 254:	70 e0       	ldi	r23, 0x00	; 0
 256:	8a e0       	ldi	r24, 0x0A	; 10
 258:	91 e0       	ldi	r25, 0x01	; 1
 25a:	0e 94 b9 04 	call	0x972	; 0x972 <modbusExchangeBits>
				SetOuts(outstate);
 25e:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <outstate>
 262:	0e 94 6c 00 	call	0xd8	; 0xd8 <SetOuts>
			}
			break;
 266:	0c c0       	rjmp	.+24     	; 0x280 <modbusGet+0x128>
			
			case fcPresetMultipleRegisters: {
				modbusExchangeRegisters(holdingRegisters,0,4);
 268:	44 e0       	ldi	r20, 0x04	; 4
 26a:	50 e0       	ldi	r21, 0x00	; 0
 26c:	60 e0       	ldi	r22, 0x00	; 0
 26e:	70 e0       	ldi	r23, 0x00	; 0
 270:	81 e1       	ldi	r24, 0x11	; 17
 272:	91 e0       	ldi	r25, 0x01	; 1
 274:	0e 94 19 04 	call	0x832	; 0x832 <modbusExchangeRegisters>
			}
			break;
 278:	03 c0       	rjmp	.+6      	; 0x280 <modbusGet+0x128>
			
			default: {
				modbusSendException(ecIllegalFunction);
 27a:	81 e0       	ldi	r24, 0x01	; 1
 27c:	0e 94 d7 03 	call	0x7ae	; 0x7ae <modbusSendException>
			}
			break;
		}
	}
}
 280:	0f 90       	pop	r0
 282:	df 91       	pop	r29
 284:	cf 91       	pop	r28
 286:	08 95       	ret

00000288 <__vector_21>:
//
//}


ISR(ADC_vect)
{
 288:	1f 92       	push	r1
 28a:	0f 92       	push	r0
 28c:	0f b6       	in	r0, 0x3f	; 63
 28e:	0f 92       	push	r0
 290:	11 24       	eor	r1, r1
 292:	2f 93       	push	r18
 294:	3f 93       	push	r19
 296:	8f 93       	push	r24
 298:	9f 93       	push	r25
 29a:	af 93       	push	r26
 29c:	bf 93       	push	r27
 29e:	ef 93       	push	r30
 2a0:	ff 93       	push	r31


		static uint16_t i;
		static uint16_t j;

		if (j++ >100)
 2a2:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <j.1814>
 2a6:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <j.1814+0x1>
 2aa:	9c 01       	movw	r18, r24
 2ac:	2f 5f       	subi	r18, 0xFF	; 255
 2ae:	3f 4f       	sbci	r19, 0xFF	; 255
 2b0:	30 93 05 01 	sts	0x0105, r19	; 0x800105 <j.1814+0x1>
 2b4:	20 93 04 01 	sts	0x0104, r18	; 0x800104 <j.1814>
 2b8:	85 36       	cpi	r24, 0x65	; 101
 2ba:	91 05       	cpc	r25, r1
 2bc:	c8 f0       	brcs	.+50     	; 0x2f0 <__vector_21+0x68>
		{
			
			if (i++ >20)
 2be:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_end>
 2c2:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <__data_end+0x1>
 2c6:	9c 01       	movw	r18, r24
 2c8:	2f 5f       	subi	r18, 0xFF	; 255
 2ca:	3f 4f       	sbci	r19, 0xFF	; 255
 2cc:	30 93 03 01 	sts	0x0103, r19	; 0x800103 <__data_end+0x1>
 2d0:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__data_end>
 2d4:	45 97       	sbiw	r24, 0x15	; 21
 2d6:	40 f0       	brcs	.+16     	; 0x2e8 <__vector_21+0x60>
			{
				TOGGLE(B,1);
 2d8:	95 b1       	in	r25, 0x05	; 5
 2da:	82 e0       	ldi	r24, 0x02	; 2
 2dc:	89 27       	eor	r24, r25
 2de:	85 b9       	out	0x05, r24	; 5
				i = 0;
 2e0:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <__data_end+0x1>
 2e4:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <__data_end>
			}

			j=0;
 2e8:	10 92 05 01 	sts	0x0105, r1	; 0x800105 <j.1814+0x1>
 2ec:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <j.1814>
		}
		

		static uint8_t first_convervision = 1;

		if (++first_convervision >1)
 2f0:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__data_start>
 2f4:	81 e0       	ldi	r24, 0x01	; 1
 2f6:	89 0f       	add	r24, r25
 2f8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 2fc:	82 30       	cpi	r24, 0x02	; 2
 2fe:	70 f1       	brcs	.+92     	; 0x35c <__vector_21+0xd4>
		{

		

		ADCSRA &= ~(1<<ADEN);
 300:	ea e7       	ldi	r30, 0x7A	; 122
 302:	f0 e0       	ldi	r31, 0x00	; 0
 304:	80 81       	ld	r24, Z
 306:	8f 77       	andi	r24, 0x7F	; 127
 308:	80 83       	st	Z, r24
		 uint8_t adc_MUX_tmp = (ADMUX & 0x0f);
 30a:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
 30e:	8f 70       	andi	r24, 0x0F	; 15
		 

		 inputRegisters[adc_MUX_tmp] = ADC;
 310:	e8 2f       	mov	r30, r24
 312:	f0 e0       	ldi	r31, 0x00	; 0
 314:	a8 e7       	ldi	r26, 0x78	; 120
 316:	b0 e0       	ldi	r27, 0x00	; 0
 318:	2d 91       	ld	r18, X+
 31a:	3c 91       	ld	r19, X
 31c:	11 97       	sbiw	r26, 0x01	; 1
 31e:	ee 0f       	add	r30, r30
 320:	ff 1f       	adc	r31, r31
 322:	ef 5d       	subi	r30, 0xDF	; 223
 324:	fe 4f       	sbci	r31, 0xFE	; 254
 326:	31 83       	std	Z+1, r19	; 0x01
 328:	20 83       	st	Z, r18

		 ADC = 0;
 32a:	11 96       	adiw	r26, 0x01	; 1
 32c:	1c 92       	st	X, r1
 32e:	1e 92       	st	-X, r1

		 adc_MUX_tmp++;
 330:	8f 5f       	subi	r24, 0xFF	; 255

		 if (adc_MUX_tmp >=6)
 332:	86 30       	cpi	r24, 0x06	; 6
 334:	08 f0       	brcs	.+2      	; 0x338 <__vector_21+0xb0>
		 {
			adc_MUX_tmp=0;
 336:	80 e0       	ldi	r24, 0x00	; 0
		 }
		
		ADMUX = (ADMUX & 0xf0) | adc_MUX_tmp;
 338:	ec e7       	ldi	r30, 0x7C	; 124
 33a:	f0 e0       	ldi	r31, 0x00	; 0
 33c:	90 81       	ld	r25, Z
 33e:	90 7f       	andi	r25, 0xF0	; 240
 340:	89 2b       	or	r24, r25
 342:	80 83       	st	Z, r24

		ADCSRA |= (1<< ADEN);
 344:	ea e7       	ldi	r30, 0x7A	; 122
 346:	f0 e0       	ldi	r31, 0x00	; 0
 348:	80 81       	ld	r24, Z
 34a:	80 68       	ori	r24, 0x80	; 128
 34c:	80 83       	st	Z, r24


		
		first_convervision = 1;
 34e:	81 e0       	ldi	r24, 0x01	; 1
 350:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
		ADCSRA |= (1 << ADSC);
 354:	80 81       	ld	r24, Z
 356:	80 64       	ori	r24, 0x40	; 64
 358:	80 83       	st	Z, r24
 35a:	03 c0       	rjmp	.+6      	; 0x362 <__vector_21+0xda>

		}
		else
		{
		++first_convervision;
 35c:	9e 5f       	subi	r25, 0xFE	; 254
 35e:	90 93 00 01 	sts	0x0100, r25	; 0x800100 <__data_start>
		}



}
 362:	ff 91       	pop	r31
 364:	ef 91       	pop	r30
 366:	bf 91       	pop	r27
 368:	af 91       	pop	r26
 36a:	9f 91       	pop	r25
 36c:	8f 91       	pop	r24
 36e:	3f 91       	pop	r19
 370:	2f 91       	pop	r18
 372:	0f 90       	pop	r0
 374:	0f be       	out	0x3f, r0	; 63
 376:	0f 90       	pop	r0
 378:	1f 90       	pop	r1
 37a:	18 95       	reti

0000037c <main>:
}

int main(void)
{
	
	OUTPUT(B,0);
 37c:	20 9a       	sbi	0x04, 0	; 4
	OUTPUT(B,1);
 37e:	21 9a       	sbi	0x04, 1	; 4


	OUTPUT(B,5);
 380:	25 9a       	sbi	0x04, 5	; 4

	DDRB = 0xff;
 382:	8f ef       	ldi	r24, 0xFF	; 255
 384:	84 b9       	out	0x04, r24	; 4

	io_conf();
 386:	0e 94 83 00 	call	0x106	; 0x106 <io_conf>


static void setup_adc(void)  // by ADC SETUP
{
	/* AVcc as reference, ADC0 as input */
	ADMUX =  0;
 38a:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>

	/* Enable ADC and conversion complete interrupt. Trigger first conversion */
	ADCSRA = (1 << ADEN) | (1 << ADIE) | (1 << ADATE);
 38e:	ea e7       	ldi	r30, 0x7A	; 122
 390:	f0 e0       	ldi	r31, 0x00	; 0
 392:	88 ea       	ldi	r24, 0xA8	; 168
 394:	80 83       	st	Z, r24
	ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); // 128 prescale
 396:	80 81       	ld	r24, Z
 398:	87 60       	ori	r24, 0x07	; 7
 39a:	80 83       	st	Z, r24


	/* Trigger first conversion */
	ADCSRA |= (1 << ADSC);
 39c:	80 81       	ld	r24, Z
 39e:	80 64       	ori	r24, 0x40	; 64
 3a0:	80 83       	st	Z, r24

	io_conf();

	setup_adc();

	sei();
 3a2:	78 94       	sei
	modbusSetAddress(clientAddress);
 3a4:	81 e0       	ldi	r24, 0x01	; 1
 3a6:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <modbusSetAddress>
	modbusInit();
 3aa:	0e 94 a8 03 	call	0x750	; 0x750 <modbusInit>
    
	timer0100us_start();
 3ae:	0e 94 63 00 	call	0xc6	; 0xc6 <timer0100us_start>
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
 3b2:	9f e0       	ldi	r25, 0x0F	; 15
 3b4:	88 e1       	ldi	r24, 0x18	; 24
 3b6:	0f b6       	in	r0, 0x3f	; 63
 3b8:	f8 94       	cli
 3ba:	a8 95       	wdr
 3bc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
 3c0:	0f be       	out	0x3f, r0	; 63
 3c2:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>

uint8_t tmp=0;
		if (READ(D,7) == HIGH)
		{
		
		SETp(tmp,3);
 3c6:	d8 e0       	ldi	r29, 0x08	; 8
			

		}
		else
		{
			CLEARp(tmp,3);
 3c8:	c0 e0       	ldi	r28, 0x00	; 0
	

wdt_enable(7);
    while(1)
    {
		wdt_reset();
 3ca:	a8 95       	wdr
	    modbusGet();
 3cc:	0e 94 ac 00 	call	0x158	; 0x158 <modbusGet>


uint8_t tmp=0;
		if (READ(D,7) == HIGH)
 3d0:	4f 99       	sbic	0x09, 7	; 9
 3d2:	02 c0       	rjmp	.+4      	; 0x3d8 <main+0x5c>
			

		}
		else
		{
			CLEARp(tmp,3);
 3d4:	8c 2f       	mov	r24, r28
 3d6:	01 c0       	rjmp	.+2      	; 0x3da <main+0x5e>

uint8_t tmp=0;
		if (READ(D,7) == HIGH)
		{
		
		SETp(tmp,3);
 3d8:	8d 2f       	mov	r24, r29
		}
		else
		{
			CLEARp(tmp,3);
		}
SetOuts(tmp);
 3da:	0e 94 6c 00 	call	0xd8	; 0xd8 <SetOuts>

    }
 3de:	f5 cf       	rjmp	.-22     	; 0x3ca <main+0x4e>

000003e0 <modbusGetBusState>:
*          amount must not be bigger than 255...
*
*/
void listRegisterCopy(volatile uint8_t *source, volatile uint8_t *target, uint8_t amount)
{
	for (uint8_t c=0; c<amount; c++)
 3e0:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 3e4:	08 95       	ret

000003e6 <modbusSetAddress>:
 3e6:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <Address>
 3ea:	08 95       	ret

000003ec <crc16>:
 3ec:	cf 93       	push	r28
 3ee:	df 93       	push	r29
 3f0:	ec 01       	movw	r28, r24
 3f2:	6f 5f       	subi	r22, 0xFF	; 255
 3f4:	d9 f0       	breq	.+54     	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
 3f6:	fc 01       	movw	r30, r24
 3f8:	dc 01       	movw	r26, r24
 3fa:	a6 0f       	add	r26, r22
 3fc:	b1 1d       	adc	r27, r1
 3fe:	2f ef       	ldi	r18, 0xFF	; 255
 400:	3f ef       	ldi	r19, 0xFF	; 255
 402:	90 81       	ld	r25, Z
 404:	29 27       	eor	r18, r25
 406:	98 e0       	ldi	r25, 0x08	; 8
 408:	a9 01       	movw	r20, r18
 40a:	41 70       	andi	r20, 0x01	; 1
 40c:	55 27       	eor	r21, r21
 40e:	36 95       	lsr	r19
 410:	27 95       	ror	r18
 412:	45 2b       	or	r20, r21
 414:	21 f0       	breq	.+8      	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
 416:	81 e0       	ldi	r24, 0x01	; 1
 418:	28 27       	eor	r18, r24
 41a:	80 ea       	ldi	r24, 0xA0	; 160
 41c:	38 27       	eor	r19, r24
 41e:	91 50       	subi	r25, 0x01	; 1
 420:	99 f7       	brne	.-26     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
 422:	31 96       	adiw	r30, 0x01	; 1
 424:	ea 17       	cp	r30, r26
 426:	fb 07       	cpc	r31, r27
 428:	61 f7       	brne	.-40     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
 42a:	02 c0       	rjmp	.+4      	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
 42c:	2f ef       	ldi	r18, 0xFF	; 255
 42e:	3f ef       	ldi	r19, 0xFF	; 255
 430:	46 2f       	mov	r20, r22
 432:	50 e0       	ldi	r21, 0x00	; 0
 434:	fe 01       	movw	r30, r28
 436:	e4 0f       	add	r30, r20
 438:	f5 1f       	adc	r31, r21
 43a:	80 81       	ld	r24, Z
 43c:	90 e0       	ldi	r25, 0x00	; 0
 43e:	b9 01       	movw	r22, r18
 440:	77 27       	eor	r23, r23
 442:	86 17       	cp	r24, r22
 444:	97 07       	cpc	r25, r23
 446:	59 f4       	brne	.+22     	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
 448:	da 01       	movw	r26, r20
 44a:	11 96       	adiw	r26, 0x01	; 1
 44c:	ac 0f       	add	r26, r28
 44e:	bd 1f       	adc	r27, r29
 450:	8c 91       	ld	r24, X
 452:	90 e0       	ldi	r25, 0x00	; 0
 454:	63 2f       	mov	r22, r19
 456:	77 27       	eor	r23, r23
 458:	86 17       	cp	r24, r22
 45a:	97 07       	cpc	r25, r23
 45c:	49 f0       	breq	.+18     	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
 45e:	20 83       	st	Z, r18
 460:	4f 5f       	subi	r20, 0xFF	; 255
 462:	5f 4f       	sbci	r21, 0xFF	; 255
 464:	fe 01       	movw	r30, r28
 466:	e4 0f       	add	r30, r20
 468:	f5 1f       	adc	r31, r21
 46a:	30 83       	st	Z, r19
 46c:	80 e0       	ldi	r24, 0x00	; 0
 46e:	01 c0       	rjmp	.+2      	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
 470:	81 e0       	ldi	r24, 0x01	; 1
 472:	df 91       	pop	r29
 474:	cf 91       	pop	r28
 476:	08 95       	ret

00000478 <listBitCopy>:
*
*
*/
void listBitCopy(volatile uint8_t *source, uint16_t sourceNr,volatile uint8_t *target, uint16_t targetNr)
{
	if(*(source+(sourceNr/8))&(1<<(sourceNr-((sourceNr/8)*8))))
 478:	fb 01       	movw	r30, r22
 47a:	f6 95       	lsr	r31
 47c:	e7 95       	ror	r30
 47e:	f6 95       	lsr	r31
 480:	e7 95       	ror	r30
 482:	f6 95       	lsr	r31
 484:	e7 95       	ror	r30
 486:	e8 0f       	add	r30, r24
 488:	f9 1f       	adc	r31, r25
 48a:	80 81       	ld	r24, Z
 48c:	90 e0       	ldi	r25, 0x00	; 0
 48e:	67 70       	andi	r22, 0x07	; 7
 490:	77 27       	eor	r23, r23
 492:	02 c0       	rjmp	.+4      	; 0x498 <listBitCopy+0x20>
 494:	95 95       	asr	r25
 496:	87 95       	ror	r24
 498:	6a 95       	dec	r22
 49a:	e2 f7       	brpl	.-8      	; 0x494 <listBitCopy+0x1c>
 49c:	80 ff       	sbrs	r24, 0
 49e:	16 c0       	rjmp	.+44     	; 0x4cc <listBitCopy+0x54>
	{
		*(target+(targetNr/8))|=(1<<(targetNr-((targetNr/8)*8)));
 4a0:	f9 01       	movw	r30, r18
 4a2:	f6 95       	lsr	r31
 4a4:	e7 95       	ror	r30
 4a6:	f6 95       	lsr	r31
 4a8:	e7 95       	ror	r30
 4aa:	f6 95       	lsr	r31
 4ac:	e7 95       	ror	r30
 4ae:	e4 0f       	add	r30, r20
 4b0:	f5 1f       	adc	r31, r21
 4b2:	40 81       	ld	r20, Z
 4b4:	27 70       	andi	r18, 0x07	; 7
 4b6:	33 27       	eor	r19, r19
 4b8:	81 e0       	ldi	r24, 0x01	; 1
 4ba:	90 e0       	ldi	r25, 0x00	; 0
 4bc:	02 c0       	rjmp	.+4      	; 0x4c2 <listBitCopy+0x4a>
 4be:	88 0f       	add	r24, r24
 4c0:	99 1f       	adc	r25, r25
 4c2:	2a 95       	dec	r18
 4c4:	e2 f7       	brpl	.-8      	; 0x4be <listBitCopy+0x46>
 4c6:	84 2b       	or	r24, r20
 4c8:	80 83       	st	Z, r24
 4ca:	08 95       	ret
	} else *(target+(targetNr/8))&=~(1<<(targetNr-((targetNr/8)*8)));
 4cc:	f9 01       	movw	r30, r18
 4ce:	f6 95       	lsr	r31
 4d0:	e7 95       	ror	r30
 4d2:	f6 95       	lsr	r31
 4d4:	e7 95       	ror	r30
 4d6:	f6 95       	lsr	r31
 4d8:	e7 95       	ror	r30
 4da:	e4 0f       	add	r30, r20
 4dc:	f5 1f       	adc	r31, r21
 4de:	40 81       	ld	r20, Z
 4e0:	27 70       	andi	r18, 0x07	; 7
 4e2:	33 27       	eor	r19, r19
 4e4:	81 e0       	ldi	r24, 0x01	; 1
 4e6:	90 e0       	ldi	r25, 0x00	; 0
 4e8:	02 c0       	rjmp	.+4      	; 0x4ee <listBitCopy+0x76>
 4ea:	88 0f       	add	r24, r24
 4ec:	99 1f       	adc	r25, r25
 4ee:	2a 95       	dec	r18
 4f0:	e2 f7       	brpl	.-8      	; 0x4ea <listBitCopy+0x72>
 4f2:	80 95       	com	r24
 4f4:	84 23       	and	r24, r20
 4f6:	80 83       	st	Z, r24
 4f8:	08 95       	ret

000004fa <modbusReset>:
/* @brief: Back to receiving state.
*
*/
void modbusReset(void)
{
	BusState=(1<<TimerActive); //stop receiving (error)
 4fa:	80 e2       	ldi	r24, 0x20	; 32
 4fc:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <BusState>
	modbusTimer=0;
 500:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <modbusTimer+0x1>
 504:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <modbusTimer>
 508:	08 95       	ret

0000050a <modbusTickTimer>:
}

void modbusTickTimer(void)
{
	if (BusState&(1<<TimerActive)) 
 50a:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 50e:	85 ff       	sbrs	r24, 5
 510:	41 c0       	rjmp	.+130    	; 0x594 <modbusTickTimer+0x8a>
	{
		modbusTimer++;
 512:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <modbusTimer>
 516:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <modbusTimer+0x1>
 51a:	01 96       	adiw	r24, 0x01	; 1
 51c:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <modbusTimer+0x1>
 520:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <modbusTimer>
		if (BusState&(1<<Receiving)) //we are in receiving mode
 524:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 528:	81 ff       	sbrs	r24, 1
 52a:	29 c0       	rjmp	.+82     	; 0x57e <modbusTickTimer+0x74>
		{
			if ((modbusTimer==modbusInterCharTimeout)) {
 52c:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <modbusTimer>
 530:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <modbusTimer+0x1>
 534:	07 97       	sbiw	r24, 0x07	; 7
 536:	31 f4       	brne	.+12     	; 0x544 <modbusTickTimer+0x3a>
				BusState|=(1<<GapDetected);
 538:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 53c:	80 64       	ori	r24, 0x40	; 64
 53e:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <BusState>
 542:	08 95       	ret
			} else if ((modbusTimer==modbusInterFrameDelayReceiveEnd)) { //end of message
 544:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <modbusTimer>
 548:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <modbusTimer+0x1>
 54c:	42 97       	sbiw	r24, 0x12	; 18
 54e:	11 f5       	brne	.+68     	; 0x594 <modbusTickTimer+0x8a>
				BusState=(1<<ReceiveCompleted);
 550:	88 e0       	ldi	r24, 0x08	; 8
 552:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <BusState>
				#if ADDRESS_MODE == MULTIPLE_ADR
               		 if (crc16(rxbuffer,DataPos-3)) { //perform crc check only. This is for multiple/all address mode.
                	} else modbusReset();
				#endif
				#if ADDRESS_MODE == SINGLE_ADR
				if (rxbuffer[0]==Address && crc16(rxbuffer,DataPos-3)) { //is the message for us? => perform crc check
 556:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <rxbuffer>
 55a:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <Address>
 55e:	98 13       	cpse	r25, r24
 560:	0b c0       	rjmp	.+22     	; 0x578 <modbusTickTimer+0x6e>
 562:	60 91 0f 01 	lds	r22, 0x010F	; 0x80010f <DataPos>
 566:	70 91 10 01 	lds	r23, 0x0110	; 0x800110 <DataPos+0x1>
 56a:	63 50       	subi	r22, 0x03	; 3
 56c:	81 e3       	ldi	r24, 0x31	; 49
 56e:	91 e0       	ldi	r25, 0x01	; 1
 570:	0e 94 f6 01 	call	0x3ec	; 0x3ec <crc16>
 574:	81 11       	cpse	r24, r1
 576:	0e c0       	rjmp	.+28     	; 0x594 <modbusTickTimer+0x8a>
				} else modbusReset();
 578:	0e 94 7d 02 	call	0x4fa	; 0x4fa <modbusReset>
 57c:	08 95       	ret
				#endif
			}	
		} else if (modbusTimer==modbusInterFrameDelayReceiveStart) BusState|=(1<<BusTimedOut);
 57e:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <modbusTimer>
 582:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <modbusTimer+0x1>
 586:	40 97       	sbiw	r24, 0x10	; 16
 588:	29 f4       	brne	.+10     	; 0x594 <modbusTickTimer+0x8a>
 58a:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 58e:	81 60       	ori	r24, 0x01	; 1
 590:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <BusState>
 594:	08 95       	ret

00000596 <__vector_18>:
	}
}

ISR(UART_RECEIVE_INTERRUPT)
{
 596:	1f 92       	push	r1
 598:	0f 92       	push	r0
 59a:	0f b6       	in	r0, 0x3f	; 63
 59c:	0f 92       	push	r0
 59e:	11 24       	eor	r1, r1
 5a0:	2f 93       	push	r18
 5a2:	3f 93       	push	r19
 5a4:	4f 93       	push	r20
 5a6:	5f 93       	push	r21
 5a8:	6f 93       	push	r22
 5aa:	7f 93       	push	r23
 5ac:	8f 93       	push	r24
 5ae:	9f 93       	push	r25
 5b0:	af 93       	push	r26
 5b2:	bf 93       	push	r27
 5b4:	ef 93       	push	r30
 5b6:	ff 93       	push	r31
	unsigned char data;
	data = UART_DATA;
 5b8:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	modbusTimer=0; //reset timer
 5bc:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <modbusTimer+0x1>
 5c0:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <modbusTimer>
	if (!(BusState & (1<<ReceiveCompleted)) && !(BusState & (1<<TransmitRequested)) && !(BusState & (1<<Transmitting)) && (BusState & (1<<Receiving)) && !(BusState & (1<<BusTimedOut)))
 5c4:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 5c8:	83 fd       	sbrc	r24, 3
 5ca:	2c c0       	rjmp	.+88     	; 0x624 <__vector_18+0x8e>
 5cc:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 5d0:	84 fd       	sbrc	r24, 4
 5d2:	28 c0       	rjmp	.+80     	; 0x624 <__vector_18+0x8e>
 5d4:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 5d8:	82 fd       	sbrc	r24, 2
 5da:	24 c0       	rjmp	.+72     	; 0x624 <__vector_18+0x8e>
 5dc:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 5e0:	81 ff       	sbrs	r24, 1
 5e2:	20 c0       	rjmp	.+64     	; 0x624 <__vector_18+0x8e>
 5e4:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 5e8:	80 fd       	sbrc	r24, 0
 5ea:	1c c0       	rjmp	.+56     	; 0x624 <__vector_18+0x8e>
	{
		if (DataPos>MaxFrameIndex) modbusReset();
 5ec:	20 91 0f 01 	lds	r18, 0x010F	; 0x80010f <DataPos>
 5f0:	30 91 10 01 	lds	r19, 0x0110	; 0x800110 <DataPos+0x1>
 5f4:	2f 3f       	cpi	r18, 0xFF	; 255
 5f6:	31 05       	cpc	r19, r1
 5f8:	21 f0       	breq	.+8      	; 0x602 <__vector_18+0x6c>
 5fa:	18 f0       	brcs	.+6      	; 0x602 <__vector_18+0x6c>
 5fc:	0e 94 7d 02 	call	0x4fa	; 0x4fa <modbusReset>
 600:	30 c0       	rjmp	.+96     	; 0x662 <__vector_18+0xcc>
	    	else
		{
			rxbuffer[DataPos]=data;
 602:	e0 91 0f 01 	lds	r30, 0x010F	; 0x80010f <DataPos>
 606:	f0 91 10 01 	lds	r31, 0x0110	; 0x800110 <DataPos+0x1>
 60a:	ef 5c       	subi	r30, 0xCF	; 207
 60c:	fe 4f       	sbci	r31, 0xFE	; 254
 60e:	90 83       	st	Z, r25
			DataPos++; //TODO: maybe prevent this from exceeding 255?
 610:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <DataPos>
 614:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <DataPos+0x1>
 618:	01 96       	adiw	r24, 0x01	; 1
 61a:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <DataPos+0x1>
 61e:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <DataPos>
 622:	1f c0       	rjmp	.+62     	; 0x662 <__vector_18+0xcc>
		}	    
    	} else 
	if (!(BusState & (1<<ReceiveCompleted)) && !(BusState & (1<<TransmitRequested)) && !(BusState & (1<<Transmitting)) && !(BusState & (1<<Receiving)) && (BusState & (1<<BusTimedOut))) 
 624:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 628:	83 fd       	sbrc	r24, 3
 62a:	1b c0       	rjmp	.+54     	; 0x662 <__vector_18+0xcc>
 62c:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 630:	84 fd       	sbrc	r24, 4
 632:	17 c0       	rjmp	.+46     	; 0x662 <__vector_18+0xcc>
 634:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 638:	82 fd       	sbrc	r24, 2
 63a:	13 c0       	rjmp	.+38     	; 0x662 <__vector_18+0xcc>
 63c:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 640:	81 fd       	sbrc	r24, 1
 642:	0f c0       	rjmp	.+30     	; 0x662 <__vector_18+0xcc>
 644:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 648:	80 ff       	sbrs	r24, 0
 64a:	0b c0       	rjmp	.+22     	; 0x662 <__vector_18+0xcc>
	{ 
		 rxbuffer[0]=data;
 64c:	90 93 31 01 	sts	0x0131, r25	; 0x800131 <rxbuffer>
		 BusState=((1<<Receiving)|(1<<TimerActive));
 650:	82 e2       	ldi	r24, 0x22	; 34
 652:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <BusState>
		 DataPos=1;
 656:	81 e0       	ldi	r24, 0x01	; 1
 658:	90 e0       	ldi	r25, 0x00	; 0
 65a:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <DataPos+0x1>
 65e:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <DataPos>
    	}
}
 662:	ff 91       	pop	r31
 664:	ef 91       	pop	r30
 666:	bf 91       	pop	r27
 668:	af 91       	pop	r26
 66a:	9f 91       	pop	r25
 66c:	8f 91       	pop	r24
 66e:	7f 91       	pop	r23
 670:	6f 91       	pop	r22
 672:	5f 91       	pop	r21
 674:	4f 91       	pop	r20
 676:	3f 91       	pop	r19
 678:	2f 91       	pop	r18
 67a:	0f 90       	pop	r0
 67c:	0f be       	out	0x3f, r0	; 63
 67e:	0f 90       	pop	r0
 680:	1f 90       	pop	r1
 682:	18 95       	reti

00000684 <__vector_19>:

ISR(UART_TRANSMIT_INTERRUPT)
{
 684:	1f 92       	push	r1
 686:	0f 92       	push	r0
 688:	0f b6       	in	r0, 0x3f	; 63
 68a:	0f 92       	push	r0
 68c:	11 24       	eor	r1, r1
 68e:	2f 93       	push	r18
 690:	3f 93       	push	r19
 692:	8f 93       	push	r24
 694:	9f 93       	push	r25
 696:	ef 93       	push	r30
 698:	ff 93       	push	r31
	BusState&=~(1<<TransmitRequested);
 69a:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 69e:	8f 7e       	andi	r24, 0xEF	; 239
 6a0:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <BusState>
	BusState|=(1<<Transmitting);
 6a4:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 6a8:	84 60       	ori	r24, 0x04	; 4
 6aa:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <BusState>
	UART_DATA=rxbuffer[DataPos];
 6ae:	e0 91 0f 01 	lds	r30, 0x010F	; 0x80010f <DataPos>
 6b2:	f0 91 10 01 	lds	r31, 0x0110	; 0x800110 <DataPos+0x1>
 6b6:	ef 5c       	subi	r30, 0xCF	; 207
 6b8:	fe 4f       	sbci	r31, 0xFE	; 254
 6ba:	80 81       	ld	r24, Z
 6bc:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	DataPos++;
 6c0:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <DataPos>
 6c4:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <DataPos+0x1>
 6c8:	01 96       	adiw	r24, 0x01	; 1
 6ca:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <DataPos+0x1>
 6ce:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <DataPos>
	if (DataPos==(PacketTopIndex+1)) {
 6d2:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <PacketTopIndex>
 6d6:	20 91 0f 01 	lds	r18, 0x010F	; 0x80010f <DataPos>
 6da:	30 91 10 01 	lds	r19, 0x0110	; 0x800110 <DataPos+0x1>
 6de:	90 e0       	ldi	r25, 0x00	; 0
 6e0:	01 96       	adiw	r24, 0x01	; 1
 6e2:	82 17       	cp	r24, r18
 6e4:	93 07       	cpc	r25, r19
 6e6:	29 f4       	brne	.+10     	; 0x6f2 <__vector_19+0x6e>
		UART_CONTROL&=~(1<<UART_UDRIE);
 6e8:	e1 ec       	ldi	r30, 0xC1	; 193
 6ea:	f0 e0       	ldi	r31, 0x00	; 0
 6ec:	80 81       	ld	r24, Z
 6ee:	8f 7d       	andi	r24, 0xDF	; 223
 6f0:	80 83       	st	Z, r24
	}
}
 6f2:	ff 91       	pop	r31
 6f4:	ef 91       	pop	r30
 6f6:	9f 91       	pop	r25
 6f8:	8f 91       	pop	r24
 6fa:	3f 91       	pop	r19
 6fc:	2f 91       	pop	r18
 6fe:	0f 90       	pop	r0
 700:	0f be       	out	0x3f, r0	; 63
 702:	0f 90       	pop	r0
 704:	1f 90       	pop	r1
 706:	18 95       	reti

00000708 <__vector_20>:

ISR(UART_TRANSMIT_COMPLETE_INTERRUPT)
{
 708:	1f 92       	push	r1
 70a:	0f 92       	push	r0
 70c:	0f b6       	in	r0, 0x3f	; 63
 70e:	0f 92       	push	r0
 710:	11 24       	eor	r1, r1
 712:	2f 93       	push	r18
 714:	3f 93       	push	r19
 716:	4f 93       	push	r20
 718:	5f 93       	push	r21
 71a:	6f 93       	push	r22
 71c:	7f 93       	push	r23
 71e:	8f 93       	push	r24
 720:	9f 93       	push	r25
 722:	af 93       	push	r26
 724:	bf 93       	push	r27
 726:	ef 93       	push	r30
 728:	ff 93       	push	r31
	#if PHYSICAL_TYPE == 485
	transceiver_rxen();
	#endif
	modbusReset();
 72a:	0e 94 7d 02 	call	0x4fa	; 0x4fa <modbusReset>
}
 72e:	ff 91       	pop	r31
 730:	ef 91       	pop	r30
 732:	bf 91       	pop	r27
 734:	af 91       	pop	r26
 736:	9f 91       	pop	r25
 738:	8f 91       	pop	r24
 73a:	7f 91       	pop	r23
 73c:	6f 91       	pop	r22
 73e:	5f 91       	pop	r21
 740:	4f 91       	pop	r20
 742:	3f 91       	pop	r19
 744:	2f 91       	pop	r18
 746:	0f 90       	pop	r0
 748:	0f be       	out	0x3f, r0	; 63
 74a:	0f 90       	pop	r0
 74c:	1f 90       	pop	r1
 74e:	18 95       	reti

00000750 <modbusInit>:

void modbusInit(void)
{
	UBRRH = (unsigned char)((UBRR) >> 8);
 750:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	UBRRL = (unsigned char) UBRR;
 754:	80 e4       	ldi	r24, 0x40	; 64
 756:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	UART_STATUS = (1<<U2X); //double speed mode.
 75a:	82 e0       	ldi	r24, 0x02	; 2
 75c:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
#ifdef URSEL   // if UBRRH and UCSRC share the same I/O location , e.g. ATmega8
	UCSRC = (1<<URSEL)|(3<<UCSZ0); //Frame Size
#else
   UCSRC = (3<<UCSZ0); //Frame Size
 760:	86 e0       	ldi	r24, 0x06	; 6
 762:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
#endif
	UART_CONTROL = (1<<TXCIE)|(1<<RXCIE)|(1<<RXEN)|(1<<TXEN); // USART receiver and transmitter and receive complete interrupt
 766:	88 ed       	ldi	r24, 0xD8	; 216
 768:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	#if PHYSICAL_TYPE == 485
	TRANSCEIVER_ENABLE_PORT_DDR|=(1<<TRANSCEIVER_ENABLE_PIN);
	transceiver_rxen();
	#endif
	BusState=(1<<TimerActive);
 76c:	80 e2       	ldi	r24, 0x20	; 32
 76e:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <BusState>
 772:	08 95       	ret

00000774 <modbusSendMessage>:
*         Arguments: - packtop: Position of the last byte containing data.
*                               modbusSendException is a good usage example.
*/
void modbusSendMessage(unsigned char packtop)
{
	PacketTopIndex=packtop+2;
 774:	92 e0       	ldi	r25, 0x02	; 2
 776:	98 0f       	add	r25, r24
 778:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <PacketTopIndex>
	crc16(rxbuffer,packtop);
 77c:	68 2f       	mov	r22, r24
 77e:	81 e3       	ldi	r24, 0x31	; 49
 780:	91 e0       	ldi	r25, 0x01	; 1
 782:	0e 94 f6 01 	call	0x3ec	; 0x3ec <crc16>
	BusState|=(1<<TransmitRequested);
 786:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 78a:	80 61       	ori	r24, 0x10	; 16
 78c:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <BusState>
	DataPos=0;
 790:	10 92 10 01 	sts	0x0110, r1	; 0x800110 <DataPos+0x1>
 794:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <DataPos>
	#if PHYSICAL_TYPE == 485
	transceiver_txen();
	#endif
	UART_CONTROL|=(1<<UART_UDRIE);
 798:	e1 ec       	ldi	r30, 0xC1	; 193
 79a:	f0 e0       	ldi	r31, 0x00	; 0
 79c:	80 81       	ld	r24, Z
 79e:	80 62       	ori	r24, 0x20	; 32
 7a0:	80 83       	st	Z, r24
	BusState&=~(1<<ReceiveCompleted);
 7a2:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <BusState>
 7a6:	87 7f       	andi	r24, 0xF7	; 247
 7a8:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <BusState>
 7ac:	08 95       	ret

000007ae <modbusSendException>:
*         Arguments: - exceptionCode
*                              
*/
void modbusSendException(unsigned char exceptionCode)
{
	rxbuffer[1]|=(1<<7); //setting MSB of the function code (the exception flag)
 7ae:	e1 e3       	ldi	r30, 0x31	; 49
 7b0:	f1 e0       	ldi	r31, 0x01	; 1
 7b2:	91 81       	ldd	r25, Z+1	; 0x01
 7b4:	90 68       	ori	r25, 0x80	; 128
 7b6:	91 83       	std	Z+1, r25	; 0x01
	rxbuffer[2]=exceptionCode; //Exceptioncode. Also the last byte containing data
 7b8:	82 83       	std	Z+2, r24	; 0x02
	modbusSendMessage(2);
 7ba:	82 e0       	ldi	r24, 0x02	; 2
 7bc:	0e 94 ba 03 	call	0x774	; 0x774 <modbusSendMessage>
 7c0:	08 95       	ret

000007c2 <modbusRequestedAmount>:
/* @brief:  Returns the amount of requested data objects (coils, discretes, registers)
*
*/
uint16_t modbusRequestedAmount(void)
{
	return (rxbuffer[5]|(rxbuffer[4]<<8));
 7c2:	e1 e3       	ldi	r30, 0x31	; 49
 7c4:	f1 e0       	ldi	r31, 0x01	; 1
 7c6:	85 81       	ldd	r24, Z+5	; 0x05
 7c8:	24 81       	ldd	r18, Z+4	; 0x04
 7ca:	90 e0       	ldi	r25, 0x00	; 0
}
 7cc:	92 2b       	or	r25, r18
 7ce:	08 95       	ret

000007d0 <modbusRequestedAddress>:
/* @brief: Returns the address of the first requested data object (coils, discretes, registers)
*
*/
uint16_t modbusRequestedAddress(void)
{
	return (rxbuffer[3]|(rxbuffer[2]<<8));
 7d0:	e1 e3       	ldi	r30, 0x31	; 49
 7d2:	f1 e0       	ldi	r31, 0x01	; 1
 7d4:	83 81       	ldd	r24, Z+3	; 0x03
 7d6:	22 81       	ldd	r18, Z+2	; 0x02
 7d8:	90 e0       	ldi	r25, 0x00	; 0
}
 7da:	92 2b       	or	r25, r18
 7dc:	08 95       	ret

000007de <intToModbusRegister>:
/* @brief: copies a single or multiple bytes from one array of bytes to an array of 16-bit-words
*
*/
void intToModbusRegister(volatile uint16_t *inreg, volatile uint8_t *outreg, uint8_t amount)
{
	for (uint8_t c=0; c<amount; c++)
 7de:	44 23       	and	r20, r20
 7e0:	81 f0       	breq	.+32     	; 0x802 <intToModbusRegister+0x24>
 7e2:	a8 2f       	mov	r26, r24
 7e4:	b9 2f       	mov	r27, r25
 7e6:	e6 2f       	mov	r30, r22
 7e8:	f7 2f       	mov	r31, r23
 7ea:	80 e0       	ldi	r24, 0x00	; 0
	{
			*(outreg+c*2) = (uint8_t)(*(inreg+c) >> 8);
 7ec:	2d 91       	ld	r18, X+
 7ee:	3c 91       	ld	r19, X
 7f0:	11 97       	sbiw	r26, 0x01	; 1
 7f2:	30 83       	st	Z, r19
			*(outreg+1+c*2) = (uint8_t)(*(inreg+c));
 7f4:	2d 91       	ld	r18, X+
 7f6:	3d 91       	ld	r19, X+
 7f8:	21 83       	std	Z+1, r18	; 0x01
/* @brief: copies a single or multiple bytes from one array of bytes to an array of 16-bit-words
*
*/
void intToModbusRegister(volatile uint16_t *inreg, volatile uint8_t *outreg, uint8_t amount)
{
	for (uint8_t c=0; c<amount; c++)
 7fa:	8f 5f       	subi	r24, 0xFF	; 255
 7fc:	32 96       	adiw	r30, 0x02	; 2
 7fe:	48 13       	cpse	r20, r24
 800:	f5 cf       	rjmp	.-22     	; 0x7ec <intToModbusRegister+0xe>
 802:	08 95       	ret

00000804 <modbusRegisterToInt>:
/* @brief: copies a single or multiple 16-bit-words from one array of integers to an array of bytes
*
*/
void modbusRegisterToInt(volatile uint8_t *inreg, volatile uint16_t *outreg, uint8_t amount)
{
	for (uint8_t c=0; c<amount; c++)
 804:	44 23       	and	r20, r20
 806:	a1 f0       	breq	.+40     	; 0x830 <modbusRegisterToInt+0x2c>
 808:	e8 2f       	mov	r30, r24
 80a:	f9 2f       	mov	r31, r25
 80c:	a6 2f       	mov	r26, r22
 80e:	b7 2f       	mov	r27, r23
 810:	20 e0       	ldi	r18, 0x00	; 0
	{
		*(outreg+c) = (*(inreg+c*2) << 8) + *(inreg+1+c*2);
 812:	80 81       	ld	r24, Z
 814:	31 81       	ldd	r19, Z+1	; 0x01
 816:	90 e0       	ldi	r25, 0x00	; 0
 818:	98 2f       	mov	r25, r24
 81a:	88 27       	eor	r24, r24
 81c:	83 0f       	add	r24, r19
 81e:	91 1d       	adc	r25, r1
 820:	11 96       	adiw	r26, 0x01	; 1
 822:	9c 93       	st	X, r25
 824:	8e 93       	st	-X, r24
 826:	12 96       	adiw	r26, 0x02	; 2
/* @brief: copies a single or multiple 16-bit-words from one array of integers to an array of bytes
*
*/
void modbusRegisterToInt(volatile uint8_t *inreg, volatile uint16_t *outreg, uint8_t amount)
{
	for (uint8_t c=0; c<amount; c++)
 828:	2f 5f       	subi	r18, 0xFF	; 255
 82a:	32 96       	adiw	r30, 0x02	; 2
 82c:	42 13       	cpse	r20, r18
 82e:	f1 cf       	rjmp	.-30     	; 0x812 <modbusRegisterToInt+0xe>
 830:	08 95       	ret

00000832 <modbusExchangeRegisters>:
*                    - startAddress: address of the first register in the supplied array
*                    - size: input array size in the requested format (16bit-registers)
*
*/
uint8_t modbusExchangeRegisters(volatile uint16_t *ptrToInArray, uint16_t startAddress, uint16_t size)
{
 832:	cf 92       	push	r12
 834:	df 92       	push	r13
 836:	ef 92       	push	r14
 838:	ff 92       	push	r15
 83a:	0f 93       	push	r16
 83c:	1f 93       	push	r17
 83e:	cf 93       	push	r28
 840:	df 93       	push	r29
 842:	6c 01       	movw	r12, r24
 844:	8b 01       	movw	r16, r22
 846:	ea 01       	movw	r28, r20
	uint16_t requestedAmount = modbusRequestedAmount();
 848:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <modbusRequestedAmount>
 84c:	7c 01       	movw	r14, r24
	uint16_t requestedAdr = modbusRequestedAddress();
 84e:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <modbusRequestedAddress>
	if (rxbuffer[1]==fcPresetSingleRegister) requestedAmount=1;
 852:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <rxbuffer+0x1>
 856:	26 30       	cpi	r18, 0x06	; 6
 858:	19 f4       	brne	.+6      	; 0x860 <modbusExchangeRegisters+0x2e>
 85a:	ee 24       	eor	r14, r14
 85c:	e3 94       	inc	r14
 85e:	f1 2c       	mov	r15, r1
	if ((requestedAdr>=startAddress) && ((startAddress+size)>=(requestedAmount+requestedAdr))) {
 860:	80 17       	cp	r24, r16
 862:	91 07       	cpc	r25, r17
 864:	08 f4       	brcc	.+2      	; 0x868 <modbusExchangeRegisters+0x36>
 866:	76 c0       	rjmp	.+236    	; 0x954 <__stack+0x55>
 868:	c0 0f       	add	r28, r16
 86a:	d1 1f       	adc	r29, r17
 86c:	97 01       	movw	r18, r14
 86e:	28 0f       	add	r18, r24
 870:	39 1f       	adc	r19, r25
 872:	c2 17       	cp	r28, r18
 874:	d3 07       	cpc	r29, r19
 876:	08 f4       	brcc	.+2      	; 0x87a <modbusExchangeRegisters+0x48>
 878:	6d c0       	rjmp	.+218    	; 0x954 <__stack+0x55>
		
		if ((rxbuffer[1]==fcReadHoldingRegisters) || (rxbuffer[1]==fcReadInputRegisters) )
 87a:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <rxbuffer+0x1>
 87e:	23 30       	cpi	r18, 0x03	; 3
 880:	21 f0       	breq	.+8      	; 0x88a <modbusExchangeRegisters+0x58>
 882:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <rxbuffer+0x1>
 886:	24 30       	cpi	r18, 0x04	; 4
 888:	09 f5       	brne	.+66     	; 0x8cc <modbusExchangeRegisters+0x9a>
		{
			if ((requestedAmount*2)<=(MaxFrameIndex-4)) //message buffer big enough?
 88a:	97 01       	movw	r18, r14
 88c:	22 0f       	add	r18, r18
 88e:	33 1f       	adc	r19, r19
 890:	2c 3f       	cpi	r18, 0xFC	; 252
 892:	31 05       	cpc	r19, r1
 894:	b0 f4       	brcc	.+44     	; 0x8c2 <modbusExchangeRegisters+0x90>
			{
				rxbuffer[2]=(unsigned char)(requestedAmount*2);
 896:	9e 2d       	mov	r25, r14
 898:	99 0f       	add	r25, r25
 89a:	c1 e3       	ldi	r28, 0x31	; 49
 89c:	d1 e0       	ldi	r29, 0x01	; 1
 89e:	9a 83       	std	Y+2, r25	; 0x02
				intToModbusRegister(ptrToInArray+(unsigned char)(requestedAdr-startAddress),rxbuffer+3,requestedAmount);
 8a0:	80 1b       	sub	r24, r16
 8a2:	90 e0       	ldi	r25, 0x00	; 0
 8a4:	88 0f       	add	r24, r24
 8a6:	99 1f       	adc	r25, r25
 8a8:	4e 2d       	mov	r20, r14
 8aa:	64 e3       	ldi	r22, 0x34	; 52
 8ac:	71 e0       	ldi	r23, 0x01	; 1
 8ae:	8c 0d       	add	r24, r12
 8b0:	9d 1d       	adc	r25, r13
 8b2:	0e 94 ef 03 	call	0x7de	; 0x7de <intToModbusRegister>
				modbusSendMessage(2+rxbuffer[2]);
 8b6:	8a 81       	ldd	r24, Y+2	; 0x02
 8b8:	8e 5f       	subi	r24, 0xFE	; 254
 8ba:	0e 94 ba 03 	call	0x774	; 0x774 <modbusSendMessage>
				return 1;
 8be:	81 e0       	ldi	r24, 0x01	; 1
 8c0:	4f c0       	rjmp	.+158    	; 0x960 <__stack+0x61>
			} else modbusSendException(ecIllegalDataValue);
 8c2:	83 e0       	ldi	r24, 0x03	; 3
 8c4:	0e 94 d7 03 	call	0x7ae	; 0x7ae <modbusSendException>
			modbusRegisterToInt(rxbuffer+4,ptrToInArray+(unsigned char)(requestedAdr-startAddress),1);
			modbusSendMessage(5);
			return 1;
		} 
		//modbusSendException(ecSlaveDeviceFailure); //inapropriate call of modbusExchangeRegisters
		return 0;
 8c8:	80 e0       	ldi	r24, 0x00	; 0
	if (rxbuffer[1]==fcPresetSingleRegister) requestedAmount=1;
	if ((requestedAdr>=startAddress) && ((startAddress+size)>=(requestedAmount+requestedAdr))) {
		
		if ((rxbuffer[1]==fcReadHoldingRegisters) || (rxbuffer[1]==fcReadInputRegisters) )
		{
			if ((requestedAmount*2)<=(MaxFrameIndex-4)) //message buffer big enough?
 8ca:	4a c0       	rjmp	.+148    	; 0x960 <__stack+0x61>
				intToModbusRegister(ptrToInArray+(unsigned char)(requestedAdr-startAddress),rxbuffer+3,requestedAmount);
				modbusSendMessage(2+rxbuffer[2]);
				return 1;
			} else modbusSendException(ecIllegalDataValue);
		}
		else if (rxbuffer[1]==fcPresetMultipleRegisters)
 8cc:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <rxbuffer+0x1>
 8d0:	20 31       	cpi	r18, 0x10	; 16
 8d2:	59 f5       	brne	.+86     	; 0x92a <__stack+0x2b>
		{
			if (((rxbuffer[6])>=requestedAmount*2) && ((DataPos-9)>=rxbuffer[6])) //enough data received?
 8d4:	20 91 37 01 	lds	r18, 0x0137	; 0x800137 <rxbuffer+0x6>
 8d8:	30 e0       	ldi	r19, 0x00	; 0
 8da:	a7 01       	movw	r20, r14
 8dc:	44 0f       	add	r20, r20
 8de:	55 1f       	adc	r21, r21
 8e0:	24 17       	cp	r18, r20
 8e2:	35 07       	cpc	r19, r21
 8e4:	e8 f0       	brcs	.+58     	; 0x920 <__stack+0x21>
 8e6:	40 91 0f 01 	lds	r20, 0x010F	; 0x80010f <DataPos>
 8ea:	50 91 10 01 	lds	r21, 0x0110	; 0x800110 <DataPos+0x1>
 8ee:	20 91 37 01 	lds	r18, 0x0137	; 0x800137 <rxbuffer+0x6>
 8f2:	49 50       	subi	r20, 0x09	; 9
 8f4:	51 09       	sbc	r21, r1
 8f6:	30 e0       	ldi	r19, 0x00	; 0
 8f8:	42 17       	cp	r20, r18
 8fa:	53 07       	cpc	r21, r19
 8fc:	88 f0       	brcs	.+34     	; 0x920 <__stack+0x21>
			{
				modbusRegisterToInt(rxbuffer+7,ptrToInArray+(unsigned char)(requestedAdr-startAddress),(unsigned char)(requestedAmount));
 8fe:	80 1b       	sub	r24, r16
 900:	68 2f       	mov	r22, r24
 902:	70 e0       	ldi	r23, 0x00	; 0
 904:	66 0f       	add	r22, r22
 906:	77 1f       	adc	r23, r23
 908:	6c 0d       	add	r22, r12
 90a:	7d 1d       	adc	r23, r13
 90c:	4e 2d       	mov	r20, r14
 90e:	88 e3       	ldi	r24, 0x38	; 56
 910:	91 e0       	ldi	r25, 0x01	; 1
 912:	0e 94 02 04 	call	0x804	; 0x804 <modbusRegisterToInt>
				modbusSendMessage(5);
 916:	85 e0       	ldi	r24, 0x05	; 5
 918:	0e 94 ba 03 	call	0x774	; 0x774 <modbusSendMessage>
				return 1;
 91c:	81 e0       	ldi	r24, 0x01	; 1
 91e:	20 c0       	rjmp	.+64     	; 0x960 <__stack+0x61>
			} else modbusSendException(ecIllegalDataValue);//too few data bytes received
 920:	83 e0       	ldi	r24, 0x03	; 3
 922:	0e 94 d7 03 	call	0x7ae	; 0x7ae <modbusSendException>
			modbusRegisterToInt(rxbuffer+4,ptrToInArray+(unsigned char)(requestedAdr-startAddress),1);
			modbusSendMessage(5);
			return 1;
		} 
		//modbusSendException(ecSlaveDeviceFailure); //inapropriate call of modbusExchangeRegisters
		return 0;
 926:	80 e0       	ldi	r24, 0x00	; 0
 928:	1b c0       	rjmp	.+54     	; 0x960 <__stack+0x61>
				modbusRegisterToInt(rxbuffer+7,ptrToInArray+(unsigned char)(requestedAdr-startAddress),(unsigned char)(requestedAmount));
				modbusSendMessage(5);
				return 1;
			} else modbusSendException(ecIllegalDataValue);//too few data bytes received
		}
		else if (rxbuffer[1]==fcPresetSingleRegister)
 92a:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <rxbuffer+0x1>
 92e:	26 30       	cpi	r18, 0x06	; 6
 930:	b1 f4       	brne	.+44     	; 0x95e <__stack+0x5f>
		{
			modbusRegisterToInt(rxbuffer+4,ptrToInArray+(unsigned char)(requestedAdr-startAddress),1);
 932:	80 1b       	sub	r24, r16
 934:	68 2f       	mov	r22, r24
 936:	70 e0       	ldi	r23, 0x00	; 0
 938:	66 0f       	add	r22, r22
 93a:	77 1f       	adc	r23, r23
 93c:	6c 0d       	add	r22, r12
 93e:	7d 1d       	adc	r23, r13
 940:	41 e0       	ldi	r20, 0x01	; 1
 942:	85 e3       	ldi	r24, 0x35	; 53
 944:	91 e0       	ldi	r25, 0x01	; 1
 946:	0e 94 02 04 	call	0x804	; 0x804 <modbusRegisterToInt>
			modbusSendMessage(5);
 94a:	85 e0       	ldi	r24, 0x05	; 5
 94c:	0e 94 ba 03 	call	0x774	; 0x774 <modbusSendMessage>
			return 1;
 950:	81 e0       	ldi	r24, 0x01	; 1
 952:	06 c0       	rjmp	.+12     	; 0x960 <__stack+0x61>
		} 
		//modbusSendException(ecSlaveDeviceFailure); //inapropriate call of modbusExchangeRegisters
		return 0;
		} else {
		modbusSendException(ecIllegalDataValue);
 954:	83 e0       	ldi	r24, 0x03	; 3
 956:	0e 94 d7 03 	call	0x7ae	; 0x7ae <modbusSendException>
		return 0;
 95a:	80 e0       	ldi	r24, 0x00	; 0
 95c:	01 c0       	rjmp	.+2      	; 0x960 <__stack+0x61>
			modbusRegisterToInt(rxbuffer+4,ptrToInArray+(unsigned char)(requestedAdr-startAddress),1);
			modbusSendMessage(5);
			return 1;
		} 
		//modbusSendException(ecSlaveDeviceFailure); //inapropriate call of modbusExchangeRegisters
		return 0;
 95e:	80 e0       	ldi	r24, 0x00	; 0
		} else {
		modbusSendException(ecIllegalDataValue);
		return 0;
	}
}
 960:	df 91       	pop	r29
 962:	cf 91       	pop	r28
 964:	1f 91       	pop	r17
 966:	0f 91       	pop	r16
 968:	ff 90       	pop	r15
 96a:	ef 90       	pop	r14
 96c:	df 90       	pop	r13
 96e:	cf 90       	pop	r12
 970:	08 95       	ret

00000972 <modbusExchangeBits>:
*                    - startAddress: address of the first bit in the supplied array
*                    - size: input array size in the requested format (bits)
*
*/
uint8_t modbusExchangeBits(volatile uint8_t *ptrToInArray, uint16_t startAddress, uint16_t size)
{
 972:	cf 92       	push	r12
 974:	df 92       	push	r13
 976:	ef 92       	push	r14
 978:	ff 92       	push	r15
 97a:	0f 93       	push	r16
 97c:	1f 93       	push	r17
 97e:	cf 93       	push	r28
 980:	df 93       	push	r29
 982:	6c 01       	movw	r12, r24
 984:	7b 01       	movw	r14, r22
 986:	ea 01       	movw	r28, r20
	uint16_t requestedAmount = modbusRequestedAmount();
 988:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <modbusRequestedAmount>
 98c:	8c 01       	movw	r16, r24
	uint16_t requestedAdr = modbusRequestedAddress();
 98e:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <modbusRequestedAddress>
	if (rxbuffer[1]==fcForceSingleCoil) requestedAmount=1;
 992:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <rxbuffer+0x1>
 996:	25 30       	cpi	r18, 0x05	; 5
 998:	11 f4       	brne	.+4      	; 0x99e <modbusExchangeBits+0x2c>
 99a:	01 e0       	ldi	r16, 0x01	; 1
 99c:	10 e0       	ldi	r17, 0x00	; 0
	if ((requestedAdr>=startAddress) && ((startAddress+size)>=(requestedAmount+requestedAdr)))
 99e:	8e 15       	cp	r24, r14
 9a0:	9f 05       	cpc	r25, r15
 9a2:	08 f4       	brcc	.+2      	; 0x9a6 <modbusExchangeBits+0x34>
 9a4:	a2 c0       	rjmp	.+324    	; 0xaea <modbusExchangeBits+0x178>
 9a6:	ce 0d       	add	r28, r14
 9a8:	df 1d       	adc	r29, r15
 9aa:	98 01       	movw	r18, r16
 9ac:	28 0f       	add	r18, r24
 9ae:	39 1f       	adc	r19, r25
 9b0:	c2 17       	cp	r28, r18
 9b2:	d3 07       	cpc	r29, r19
 9b4:	08 f4       	brcc	.+2      	; 0x9b8 <modbusExchangeBits+0x46>
 9b6:	99 c0       	rjmp	.+306    	; 0xaea <modbusExchangeBits+0x178>
	{
		if ((rxbuffer[1]==fcReadInputStatus) || (rxbuffer[1]==fcReadCoilStatus))
 9b8:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <rxbuffer+0x1>
 9bc:	22 30       	cpi	r18, 0x02	; 2
 9be:	29 f0       	breq	.+10     	; 0x9ca <modbusExchangeBits+0x58>
 9c0:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <rxbuffer+0x1>
 9c4:	21 30       	cpi	r18, 0x01	; 1
 9c6:	09 f0       	breq	.+2      	; 0x9ca <modbusExchangeBits+0x58>
 9c8:	41 c0       	rjmp	.+130    	; 0xa4c <modbusExchangeBits+0xda>
		{
			if (requestedAmount<=((MaxFrameIndex-4)*8)) //message buffer big enough?
 9ca:	09 3d       	cpi	r16, 0xD9	; 217
 9cc:	27 e0       	ldi	r18, 0x07	; 7
 9ce:	12 07       	cpc	r17, r18
 9d0:	c0 f5       	brcc	.+112    	; 0xa42 <modbusExchangeBits+0xd0>
			{
				rxbuffer[2]=(requestedAmount/8);
 9d2:	98 01       	movw	r18, r16
 9d4:	36 95       	lsr	r19
 9d6:	27 95       	ror	r18
 9d8:	36 95       	lsr	r19
 9da:	27 95       	ror	r18
 9dc:	36 95       	lsr	r19
 9de:	27 95       	ror	r18
 9e0:	20 93 33 01 	sts	0x0133, r18	; 0x800133 <rxbuffer+0x2>
				if (requestedAmount%8>0)
 9e4:	a8 01       	movw	r20, r16
 9e6:	47 70       	andi	r20, 0x07	; 7
 9e8:	55 27       	eor	r21, r21
 9ea:	45 2b       	or	r20, r21
 9ec:	69 f0       	breq	.+26     	; 0xa08 <modbusExchangeBits+0x96>
				{
					rxbuffer[(uint8_t)(requestedAmount/8)+3]=0x00; //fill last data byte with zeros
 9ee:	33 27       	eor	r19, r19
 9f0:	a1 e3       	ldi	r26, 0x31	; 49
 9f2:	b1 e0       	ldi	r27, 0x01	; 1
 9f4:	f9 01       	movw	r30, r18
 9f6:	ec 5c       	subi	r30, 0xCC	; 204
 9f8:	fe 4f       	sbci	r31, 0xFE	; 254
 9fa:	10 82       	st	Z, r1
					rxbuffer[2]++;
 9fc:	12 96       	adiw	r26, 0x02	; 2
 9fe:	2c 91       	ld	r18, X
 a00:	12 97       	sbiw	r26, 0x02	; 2
 a02:	2f 5f       	subi	r18, 0xFF	; 255
 a04:	12 96       	adiw	r26, 0x02	; 2
 a06:	2c 93       	st	X, r18
				}
				for (uint16_t c = 0; c<requestedAmount; c++)
 a08:	01 15       	cp	r16, r1
 a0a:	11 05       	cpc	r17, r1
 a0c:	99 f0       	breq	.+38     	; 0xa34 <modbusExchangeBits+0xc2>
 a0e:	c0 e0       	ldi	r28, 0x00	; 0
 a10:	d0 e0       	ldi	r29, 0x00	; 0
				{
					listBitCopy(ptrToInArray,requestedAdr-startAddress+c,rxbuffer+3,c);
 a12:	9c 01       	movw	r18, r24
 a14:	2e 19       	sub	r18, r14
 a16:	3f 09       	sbc	r19, r15
 a18:	79 01       	movw	r14, r18
 a1a:	b7 01       	movw	r22, r14
 a1c:	6c 0f       	add	r22, r28
 a1e:	7d 1f       	adc	r23, r29
 a20:	9e 01       	movw	r18, r28
 a22:	44 e3       	ldi	r20, 0x34	; 52
 a24:	51 e0       	ldi	r21, 0x01	; 1
 a26:	c6 01       	movw	r24, r12
 a28:	0e 94 3c 02 	call	0x478	; 0x478 <listBitCopy>
				if (requestedAmount%8>0)
				{
					rxbuffer[(uint8_t)(requestedAmount/8)+3]=0x00; //fill last data byte with zeros
					rxbuffer[2]++;
				}
				for (uint16_t c = 0; c<requestedAmount; c++)
 a2c:	21 96       	adiw	r28, 0x01	; 1
 a2e:	0c 17       	cp	r16, r28
 a30:	1d 07       	cpc	r17, r29
 a32:	99 f7       	brne	.-26     	; 0xa1a <modbusExchangeBits+0xa8>
				{
					listBitCopy(ptrToInArray,requestedAdr-startAddress+c,rxbuffer+3,c);
				}
				modbusSendMessage(rxbuffer[2]+2);
 a34:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <rxbuffer+0x2>
 a38:	8e 5f       	subi	r24, 0xFE	; 254
 a3a:	0e 94 ba 03 	call	0x774	; 0x774 <modbusSendMessage>
				return 1;
 a3e:	81 e0       	ldi	r24, 0x01	; 1
 a40:	5a c0       	rjmp	.+180    	; 0xaf6 <modbusExchangeBits+0x184>
			} else modbusSendException(ecIllegalDataValue); //too many bits requested within single request
 a42:	83 e0       	ldi	r24, 0x03	; 3
 a44:	0e 94 d7 03 	call	0x7ae	; 0x7ae <modbusSendException>
			listBitCopy(rxbuffer+4,0,ptrToInArray,requestedAdr-startAddress);
			modbusSendMessage(5); 
			return 1;
		}
		//modbusSendException(ecSlaveDeviceFailure); //inanpropriate call of modbusExchangeBits
		return 0;
 a48:	80 e0       	ldi	r24, 0x00	; 0
	if (rxbuffer[1]==fcForceSingleCoil) requestedAmount=1;
	if ((requestedAdr>=startAddress) && ((startAddress+size)>=(requestedAmount+requestedAdr)))
	{
		if ((rxbuffer[1]==fcReadInputStatus) || (rxbuffer[1]==fcReadCoilStatus))
		{
			if (requestedAmount<=((MaxFrameIndex-4)*8)) //message buffer big enough?
 a4a:	55 c0       	rjmp	.+170    	; 0xaf6 <modbusExchangeBits+0x184>
				}
				modbusSendMessage(rxbuffer[2]+2);
				return 1;
			} else modbusSendException(ecIllegalDataValue); //too many bits requested within single request
		}
		else if (rxbuffer[1]==fcForceMultipleCoils)
 a4c:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <rxbuffer+0x1>
 a50:	2f 30       	cpi	r18, 0x0F	; 15
 a52:	c1 f5       	brne	.+112    	; 0xac4 <modbusExchangeBits+0x152>
		{
			if (((rxbuffer[6]*8)>=requestedAmount) && ((DataPos-9)>=rxbuffer[6])) //enough data received?
 a54:	20 91 37 01 	lds	r18, 0x0137	; 0x800137 <rxbuffer+0x6>
 a58:	30 e0       	ldi	r19, 0x00	; 0
 a5a:	22 0f       	add	r18, r18
 a5c:	33 1f       	adc	r19, r19
 a5e:	22 0f       	add	r18, r18
 a60:	33 1f       	adc	r19, r19
 a62:	22 0f       	add	r18, r18
 a64:	33 1f       	adc	r19, r19
 a66:	20 17       	cp	r18, r16
 a68:	31 07       	cpc	r19, r17
 a6a:	38 f1       	brcs	.+78     	; 0xaba <modbusExchangeBits+0x148>
 a6c:	40 91 0f 01 	lds	r20, 0x010F	; 0x80010f <DataPos>
 a70:	50 91 10 01 	lds	r21, 0x0110	; 0x800110 <DataPos+0x1>
 a74:	20 91 37 01 	lds	r18, 0x0137	; 0x800137 <rxbuffer+0x6>
 a78:	49 50       	subi	r20, 0x09	; 9
 a7a:	51 09       	sbc	r21, r1
 a7c:	30 e0       	ldi	r19, 0x00	; 0
 a7e:	42 17       	cp	r20, r18
 a80:	53 07       	cpc	r21, r19
 a82:	d8 f0       	brcs	.+54     	; 0xaba <modbusExchangeBits+0x148>
			{
				for (uint16_t c = 0; c<requestedAmount; c++)
 a84:	01 15       	cp	r16, r1
 a86:	11 05       	cpc	r17, r1
 a88:	99 f0       	breq	.+38     	; 0xab0 <modbusExchangeBits+0x13e>
 a8a:	c0 e0       	ldi	r28, 0x00	; 0
 a8c:	d0 e0       	ldi	r29, 0x00	; 0
				{
					listBitCopy(rxbuffer+7,c,ptrToInArray,requestedAdr-startAddress+c);
 a8e:	9c 01       	movw	r18, r24
 a90:	2e 19       	sub	r18, r14
 a92:	3f 09       	sbc	r19, r15
 a94:	79 01       	movw	r14, r18
 a96:	97 01       	movw	r18, r14
 a98:	2c 0f       	add	r18, r28
 a9a:	3d 1f       	adc	r19, r29
 a9c:	a6 01       	movw	r20, r12
 a9e:	be 01       	movw	r22, r28
 aa0:	88 e3       	ldi	r24, 0x38	; 56
 aa2:	91 e0       	ldi	r25, 0x01	; 1
 aa4:	0e 94 3c 02 	call	0x478	; 0x478 <listBitCopy>
		}
		else if (rxbuffer[1]==fcForceMultipleCoils)
		{
			if (((rxbuffer[6]*8)>=requestedAmount) && ((DataPos-9)>=rxbuffer[6])) //enough data received?
			{
				for (uint16_t c = 0; c<requestedAmount; c++)
 aa8:	21 96       	adiw	r28, 0x01	; 1
 aaa:	0c 17       	cp	r16, r28
 aac:	1d 07       	cpc	r17, r29
 aae:	99 f7       	brne	.-26     	; 0xa96 <modbusExchangeBits+0x124>
				{
					listBitCopy(rxbuffer+7,c,ptrToInArray,requestedAdr-startAddress+c);
				}
				modbusSendMessage(5);
 ab0:	85 e0       	ldi	r24, 0x05	; 5
 ab2:	0e 94 ba 03 	call	0x774	; 0x774 <modbusSendMessage>
				return 1;
 ab6:	81 e0       	ldi	r24, 0x01	; 1
 ab8:	1e c0       	rjmp	.+60     	; 0xaf6 <modbusExchangeBits+0x184>
			} else modbusSendException(ecIllegalDataValue);//exception too few data bytes received
 aba:	83 e0       	ldi	r24, 0x03	; 3
 abc:	0e 94 d7 03 	call	0x7ae	; 0x7ae <modbusSendException>
			listBitCopy(rxbuffer+4,0,ptrToInArray,requestedAdr-startAddress);
			modbusSendMessage(5); 
			return 1;
		}
		//modbusSendException(ecSlaveDeviceFailure); //inanpropriate call of modbusExchangeBits
		return 0;
 ac0:	80 e0       	ldi	r24, 0x00	; 0
 ac2:	19 c0       	rjmp	.+50     	; 0xaf6 <modbusExchangeBits+0x184>
				}
				modbusSendMessage(5);
				return 1;
			} else modbusSendException(ecIllegalDataValue);//exception too few data bytes received
		}
		else if (rxbuffer[1]==fcForceSingleCoil) {
 ac4:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <rxbuffer+0x1>
 ac8:	25 30       	cpi	r18, 0x05	; 5
 aca:	a1 f4       	brne	.+40     	; 0xaf4 <modbusExchangeBits+0x182>
			listBitCopy(rxbuffer+4,0,ptrToInArray,requestedAdr-startAddress);
 acc:	9c 01       	movw	r18, r24
 ace:	2e 19       	sub	r18, r14
 ad0:	3f 09       	sbc	r19, r15
 ad2:	a6 01       	movw	r20, r12
 ad4:	60 e0       	ldi	r22, 0x00	; 0
 ad6:	70 e0       	ldi	r23, 0x00	; 0
 ad8:	85 e3       	ldi	r24, 0x35	; 53
 ada:	91 e0       	ldi	r25, 0x01	; 1
 adc:	0e 94 3c 02 	call	0x478	; 0x478 <listBitCopy>
			modbusSendMessage(5); 
 ae0:	85 e0       	ldi	r24, 0x05	; 5
 ae2:	0e 94 ba 03 	call	0x774	; 0x774 <modbusSendMessage>
			return 1;
 ae6:	81 e0       	ldi	r24, 0x01	; 1
 ae8:	06 c0       	rjmp	.+12     	; 0xaf6 <modbusExchangeBits+0x184>
		}
		//modbusSendException(ecSlaveDeviceFailure); //inanpropriate call of modbusExchangeBits
		return 0;
	} else
	{
		modbusSendException(ecIllegalDataValue);
 aea:	83 e0       	ldi	r24, 0x03	; 3
 aec:	0e 94 d7 03 	call	0x7ae	; 0x7ae <modbusSendException>
		return 0;
 af0:	80 e0       	ldi	r24, 0x00	; 0
 af2:	01 c0       	rjmp	.+2      	; 0xaf6 <modbusExchangeBits+0x184>
			listBitCopy(rxbuffer+4,0,ptrToInArray,requestedAdr-startAddress);
			modbusSendMessage(5); 
			return 1;
		}
		//modbusSendException(ecSlaveDeviceFailure); //inanpropriate call of modbusExchangeBits
		return 0;
 af4:	80 e0       	ldi	r24, 0x00	; 0
	} else
	{
		modbusSendException(ecIllegalDataValue);
		return 0;
	}
}
 af6:	df 91       	pop	r29
 af8:	cf 91       	pop	r28
 afa:	1f 91       	pop	r17
 afc:	0f 91       	pop	r16
 afe:	ff 90       	pop	r15
 b00:	ef 90       	pop	r14
 b02:	df 90       	pop	r13
 b04:	cf 90       	pop	r12
 b06:	08 95       	ret

00000b08 <__tablejump2__>:
 b08:	ee 0f       	add	r30, r30
 b0a:	ff 1f       	adc	r31, r31
 b0c:	05 90       	lpm	r0, Z+
 b0e:	f4 91       	lpm	r31, Z
 b10:	e0 2d       	mov	r30, r0
 b12:	09 94       	ijmp

00000b14 <_exit>:
 b14:	f8 94       	cli

00000b16 <__stop_program>:
 b16:	ff cf       	rjmp	.-2      	; 0xb16 <__stop_program>
